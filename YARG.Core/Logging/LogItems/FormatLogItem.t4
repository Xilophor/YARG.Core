<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Linq" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Collections.Concurrent;
using Cysharp.Text;

#nullable enable

namespace YARG.Core.Logging
{
<#
const int maxGenericArguments = 10;

for (int i = 0; i < maxGenericArguments; i++)
{
    var countRange= Enumerable.Range(1, i + 1);

    var genericTypes = countRange.Select((j) => "T" + j);
    var nullableTypes = genericTypes.Select((j) => j + "?");
    var functionArgs = countRange.Select((j) => "arg" + j);
    var functionParams = nullableTypes.Zip(functionArgs, (type, arg) => type + " " + arg);

    var genericSignature = string.Join(", ", genericTypes);
    var functionSignature = string.Join(", ", functionParams);
    var functionArguments = string.Join(", ", functionArgs);
#>
    public class FormatLogItem<<#= genericSignature #>> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<<#= genericSignature #>>> _instancePool = new();

        private string Format = "";

<#
    foreach (var (type, name) in genericTypes.Zip(functionArgs, (x, y) => (x, y)))
    {
#>
        private <#= type #>? <#= name #>;
<#
    }
#>

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<<#= genericSignature #>> MakeItem(
            string format, <#= functionSignature #>)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
<#
    foreach (var arg in functionArgs)
    {
#>
            item.<#= arg #> = <#= arg #>;
<#
    }
#>
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, <#= functionArguments #>);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    public static partial class FormatLogItem
    {
        public static FormatLogItem<<#= genericSignature #>> MakeItem<<#= genericSignature #>>(
            string format, <#= functionSignature #>)
        {
            return FormatLogItem<<#= genericSignature #>>.MakeItem(
                format, <#= functionArguments #>);
        }
    }

<#
}
#>
}