//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Collections.Concurrent;
using Cysharp.Text;

#nullable enable

namespace YARG.Core.Logging
{
    internal class FormatLogItem<T1> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1>> _instancePool = new();

        private string Format = "";

        private T1? arg1;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1> MakeItem(
            string format, T1? arg1)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    internal static partial class FormatLogItem
    {
        public static FormatLogItem<T1> MakeItem<T1>(
            string format, T1? arg1)
        {
            return FormatLogItem<T1>.MakeItem(
                format, arg1);
        }
    }

    internal class FormatLogItem<T1, T2> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2> MakeItem(
            string format, T1? arg1, T2? arg2)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    internal static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2> MakeItem<T1, T2>(
            string format, T1? arg1, T2? arg2)
        {
            return FormatLogItem<T1, T2>.MakeItem(
                format, arg1, arg2);
        }
    }

    internal class FormatLogItem<T1, T2, T3> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    internal static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3> MakeItem<T1, T2, T3>(
            string format, T1? arg1, T2? arg2, T3? arg3)
        {
            return FormatLogItem<T1, T2, T3>.MakeItem(
                format, arg1, arg2, arg3);
        }
    }

    internal class FormatLogItem<T1, T2, T3, T4> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    internal static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4> MakeItem<T1, T2, T3, T4>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4)
        {
            return FormatLogItem<T1, T2, T3, T4>.MakeItem(
                format, arg1, arg2, arg3, arg4);
        }
    }

    internal class FormatLogItem<T1, T2, T3, T4, T5> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4, T5>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;
        private T5? arg5;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4, T5> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            item.arg5 = arg5;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4, arg5);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    internal static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4, T5> MakeItem<T1, T2, T3, T4, T5>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5)
        {
            return FormatLogItem<T1, T2, T3, T4, T5>.MakeItem(
                format, arg1, arg2, arg3, arg4, arg5);
        }
    }

    internal class FormatLogItem<T1, T2, T3, T4, T5, T6> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4, T5, T6>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;
        private T5? arg5;
        private T6? arg6;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4, T5, T6> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            item.arg5 = arg5;
            item.arg6 = arg6;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4, arg5, arg6);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    internal static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4, T5, T6> MakeItem<T1, T2, T3, T4, T5, T6>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6)
        {
            return FormatLogItem<T1, T2, T3, T4, T5, T6>.MakeItem(
                format, arg1, arg2, arg3, arg4, arg5, arg6);
        }
    }

    internal class FormatLogItem<T1, T2, T3, T4, T5, T6, T7> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4, T5, T6, T7>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;
        private T5? arg5;
        private T6? arg6;
        private T7? arg7;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            item.arg5 = arg5;
            item.arg6 = arg6;
            item.arg7 = arg7;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    internal static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7> MakeItem<T1, T2, T3, T4, T5, T6, T7>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7)
        {
            return FormatLogItem<T1, T2, T3, T4, T5, T6, T7>.MakeItem(
                format, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        }
    }

    internal class FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;
        private T5? arg5;
        private T6? arg6;
        private T7? arg7;
        private T8? arg8;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7, T8? arg8)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            item.arg5 = arg5;
            item.arg6 = arg6;
            item.arg7 = arg7;
            item.arg8 = arg8;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    internal static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8> MakeItem<T1, T2, T3, T4, T5, T6, T7, T8>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7, T8? arg8)
        {
            return FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8>.MakeItem(
                format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        }
    }

    internal class FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;
        private T5? arg5;
        private T6? arg6;
        private T7? arg7;
        private T8? arg8;
        private T9? arg9;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7, T8? arg8, T9? arg9)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            item.arg5 = arg5;
            item.arg6 = arg6;
            item.arg7 = arg7;
            item.arg8 = arg8;
            item.arg9 = arg9;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    internal static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9> MakeItem<T1, T2, T3, T4, T5, T6, T7, T8, T9>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7, T8? arg8, T9? arg9)
        {
            return FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9>.MakeItem(
                format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        }
    }

    internal class FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> : LogItem
    {
        private static ConcurrentBag<FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>> _instancePool = new();

        private string Format = "";

        private T1? arg1;
        private T2? arg2;
        private T3? arg3;
        private T4? arg4;
        private T5? arg5;
        private T6? arg6;
        private T7? arg7;
        private T8? arg8;
        private T9? arg9;
        private T10? arg10;

        private FormatLogItem() {}

        ~FormatLogItem()
        {
            YargLogger.LogError("Log item instance was not returned to the pool!");
        }

        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> MakeItem(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7, T8? arg8, T9? arg9, T10? arg10)
        {
            if (!_instancePool.TryTake(out var item))
                item = new();

            item.Format = format;
            item.arg1 = arg1;
            item.arg2 = arg2;
            item.arg3 = arg3;
            item.arg4 = arg4;
            item.arg5 = arg5;
            item.arg6 = arg6;
            item.arg7 = arg7;
            item.arg8 = arg8;
            item.arg9 = arg9;
            item.arg10 = arg10;
            return item;
        }

        public override void FormatMessage(ref Utf16ValueStringBuilder output)
        {
            output.AppendFormat(Format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
        }

        protected override void ReturnToPool()
        {
            _instancePool.Add(this);
        }
    }

    internal static partial class FormatLogItem
    {
        public static FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> MakeItem<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(
            string format, T1? arg1, T2? arg2, T3? arg3, T4? arg4, T5? arg5, T6? arg6, T7? arg7, T8? arg8, T9? arg9, T10? arg10)
        {
            return FormatLogItem<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>.MakeItem(
                format, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
        }
    }

}